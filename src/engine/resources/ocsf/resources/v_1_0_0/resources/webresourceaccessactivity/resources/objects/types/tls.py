# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

from ..........core.datetime_utils import serialize_datetime
from .certificate import Certificate
from .fingerprint import Fingerprint
from .san import San
from .tls_extension import TlsExtension

try:
    import pydantic.v1 as pydantic  # type: ignore
except ImportError:
    import pydantic  # type: ignore


class Tls(pydantic.BaseModel):
    """
    The Transport Layer Security (TLS) object describes the negotiated TLS protocol used for secure communications over an establish network connection.
    """

    alert: typing.Optional[int] = pydantic.Field(
        description="The integer value of TLS alert if present. The alerts are defined in the TLS specification in <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc2246'>RFC-2246</a>."
    )
    certificate: typing.Optional[Certificate] = pydantic.Field(
        description="The certificate object containing information about the digital certificate."
    )
    certificate_chain: typing.Optional[typing.List[str]] = pydantic.Field(
        description="The Chain of Certificate Serial Numbers field provides a chain of Certificate Issuer Serial Numbers leading to the Root Certificate Issuer."
    )
    cipher: typing.Optional[str] = pydantic.Field(description="The negotiated cipher suite.")
    client_ciphers: typing.Optional[typing.List[str]] = pydantic.Field(
        description="The client cipher suites that were exchanged during the TLS handshake negotiation."
    )
    extension_list: typing.Optional[typing.List[TlsExtension]] = pydantic.Field(
        description="The list of TLS extensions."
    )
    handshake_dur: typing.Optional[int] = pydantic.Field(
        description="The amount of total time for the TLS handshake to complete after the TCP connection is established, including client-side delays, in milliseconds."
    )
    ja_3_hash: typing.Optional[Fingerprint] = pydantic.Field(
        alias="ja3_hash", description="The MD5 hash of a JA3 string."
    )
    ja_3_s_hash: typing.Optional[Fingerprint] = pydantic.Field(
        alias="ja3s_hash", description="The MD5 hash of a JA3S string."
    )
    key_length: typing.Optional[int] = pydantic.Field(description="The length of the encryption key.")
    sans: typing.Optional[typing.List[San]] = pydantic.Field(
        description="The list of subject alternative names that are secured by a specific certificate."
    )
    server_ciphers: typing.Optional[typing.List[str]] = pydantic.Field(
        description="The server cipher suites that were exchanged during the TLS handshake negotiation."
    )
    sni: typing.Optional[str] = pydantic.Field(
        description="The Server Name Indication (SNI) extension sent by the client."
    )
    version: str = pydantic.Field(description="The TLS protocol version.")

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        allow_population_by_field_name = True
        json_encoders = {dt.datetime: serialize_datetime}
