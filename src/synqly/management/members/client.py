# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..common.errors.bad_request_error import BadRequestError
from ..common.errors.conflict_error import ConflictError
from ..common.errors.forbidden_error import ForbiddenError
from ..common.errors.internal_server_error import InternalServerError
from ..common.errors.method_not_allowed_error import MethodNotAllowedError
from ..common.errors.not_found_error import NotFoundError
from ..common.errors.too_many_requests_error import TooManyRequestsError
from ..common.errors.unauthorized_error import UnauthorizedError
from ..common.errors.unsupported_media_type_error import UnsupportedMediaTypeError
from ..common.types.patch_operation import PatchOperation
from ..common.types.problem import Problem
from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.request_options import RequestOptions
from ..core.unchecked_base_model import construct_type
from ..member_base.types.create_member_response import CreateMemberResponse
from ..member_base.types.member_id import MemberId
from ..member_base.types.member_options import MemberOptions
from ..member_base.types.state import State
from ..role_base.types.role_name import RoleName
from .types.get_member_response import GetMemberResponse
from .types.list_members_response import ListMembersResponse
from .types.patch_member_response import PatchMemberResponse
from .types.update_member_response import UpdateMemberResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class MembersClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        limit: typing.Optional[int] = None,
        start_after: typing.Optional[str] = None,
        order: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        filter: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListMembersResponse:
        """
        List all members

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of `Member` objects to return in this page. Defaults to 100.

        start_after : typing.Optional[str]
            Return `Member` objects starting after this `name`.

        order : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Select a field to order the results by. Defaults to `name`. To control the direction of the sorting, append
            `[asc]` or `[desc]` to the field name. For example, `name[desc]` will sort the results by `name` in descending order.
            The ordering defaults to `asc` if not specified. May be used multiple times to order by multiple fields, and the
            ordering is applied in the order the fields are specified.

        filter : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter results by this query. For more information on filtering, refer to our Filtering Guide. Defaults to no filter.
            If used more than once, the queries are ANDed together.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListMembersResponse

        Examples
        --------
        from synqly.client import SynqlyManagement

        client = SynqlyManagement(
            token="YOUR_TOKEN",
        )
        client.members.list(
            limit=1,
            start_after="string",
            order="string",
            filter="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/members",
            method="GET",
            params={"limit": limit, "start_after": start_after, "order": order, "filter": filter},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListMembersResponse, construct_type(type_=ListMembersResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, member_id: MemberId, *, request_options: typing.Optional[RequestOptions] = None) -> GetMemberResponse:
        """
        Retrieve a Member by ID

        Parameters
        ----------
        member_id : MemberId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetMemberResponse

        Examples
        --------
        from synqly.client import SynqlyManagement

        client = SynqlyManagement(
            token="YOUR_TOKEN",
        )
        client.members.get(
            member_id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/members/{jsonable_encoder(member_id)}", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(GetMemberResponse, construct_type(type_=GetMemberResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        name: str,
        secret: str,
        options: MemberOptions,
        fullname: typing.Optional[str] = OMIT,
        nickname: typing.Optional[str] = OMIT,
        picture: typing.Optional[str] = OMIT,
        role_binding: typing.Optional[typing.Sequence[RoleName]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateMemberResponse:
        """
        Add a new member for this Organization.

        Parameters
        ----------
        name : str
            Email name to use for this Member. Also used for duplicate detection and default sort order.

        secret : str
            Member secret used to logon. Must be at least 8 characters long and fewer than 72 characters. There are no restrictions on the characters used; however, the secret must be sufficiently complex. It cannot be a common word, previously leaked password, or easily guessed sequences like `qwerty` or `12345`.

        options : MemberOptions

        fullname : typing.Optional[str]
            User's full display name. Defaults to the same value as the 'name' field if not specified.

        nickname : typing.Optional[str]
            User's nickname

        picture : typing.Optional[str]
            Url of user's picture

        role_binding : typing.Optional[typing.Sequence[RoleName]]
            Roles granted to this member. Tokens inherit this access. Defaults to `member`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateMemberResponse

        Examples
        --------
        from synqly import MemberOptions
        from synqly.client import SynqlyManagement

        client = SynqlyManagement(
            token="YOUR_TOKEN",
        )
        client.members.create(
            name="string",
            fullname="string",
            nickname="string",
            picture="string",
            secret="string",
            role_binding=["string"],
            options=MemberOptions(
                ttl="string",
                options=["disabled"],
                token_ttl="string",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/members",
            method="POST",
            json={
                "name": name,
                "fullname": fullname,
                "nickname": nickname,
                "picture": picture,
                "secret": secret,
                "role_binding": role_binding,
                "options": options,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(CreateMemberResponse, construct_type(type_=CreateMemberResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        member_id: MemberId,
        *,
        id: MemberId,
        state: State,
        last_logon: dt.datetime,
        fullname: str,
        ttl: str,
        token_ttl: str,
        expires: dt.datetime,
        pin_expires: dt.datetime,
        role_binding: typing.Sequence[RoleName],
        name: str,
        created_at: dt.datetime,
        updated_at: dt.datetime,
        nickname: typing.Optional[str] = OMIT,
        picture: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateMemberResponse:
        """
        Update a Member by ID

        Parameters
        ----------
        member_id : MemberId

        id : MemberId

        state : State

        last_logon : dt.datetime
            Last logon time

        fullname : str
            User's full display name.

        ttl : str

        token_ttl : str

        expires : dt.datetime

        pin_expires : dt.datetime

        role_binding : typing.Sequence[RoleName]
            Roles granted to this member. Tokens inherit this access.

        name : str
            Human-readable name for this resource

        created_at : dt.datetime
            Time object was originally created

        updated_at : dt.datetime
            Last time object was updated

        nickname : typing.Optional[str]
            User's nickname

        picture : typing.Optional[str]
            Url of user's picture

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateMemberResponse

        Examples
        --------
        import datetime

        from synqly.client import SynqlyManagement

        client = SynqlyManagement(
            token="YOUR_TOKEN",
        )
        client.members.update(
            member_id="string",
            id="string",
            state="disabled",
            last_logon=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            fullname="string",
            nickname="string",
            picture="string",
            ttl="string",
            token_ttl="string",
            expires=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            pin_expires=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            role_binding=["string"],
            name="string",
            created_at=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
            updated_at=datetime.datetime.fromisoformat(
                "2024-01-15 09:30:00+00:00",
            ),
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/members/{jsonable_encoder(member_id)}",
            method="PUT",
            json={
                "id": id,
                "state": state,
                "last_logon": last_logon,
                "fullname": fullname,
                "nickname": nickname,
                "picture": picture,
                "ttl": ttl,
                "token_ttl": token_ttl,
                "expires": expires,
                "pin_expires": pin_expires,
                "role_binding": role_binding,
                "name": name,
                "created_at": created_at,
                "updated_at": updated_at,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(UpdateMemberResponse, construct_type(type_=UpdateMemberResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def patch(
        self,
        member_id: MemberId,
        *,
        request: typing.Sequence[PatchOperation],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PatchMemberResponse:
        """
        Update a Member by ID

        Parameters
        ----------
        member_id : MemberId

        request : typing.Sequence[PatchOperation]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PatchMemberResponse

        Examples
        --------
        from synqly import PatchOperation
        from synqly.client import SynqlyManagement

        client = SynqlyManagement(
            token="YOUR_TOKEN",
        )
        client.members.patch(
            member_id="string",
            request=[
                PatchOperation(
                    op="add",
                    path="string",
                    from_="string",
                    value={"key": "value"},
                )
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/members/{jsonable_encoder(member_id)}",
            method="PATCH",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(PatchMemberResponse, construct_type(type_=PatchMemberResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, member_id: MemberId, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a Member by ID. Also deletes all Tokens for the Member.

        Parameters
        ----------
        member_id : MemberId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from synqly.client import SynqlyManagement

        client = SynqlyManagement(
            token="YOUR_TOKEN",
        )
        client.members.delete(
            member_id="string",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v1/members/{jsonable_encoder(member_id)}", method="DELETE", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncMembersClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        limit: typing.Optional[int] = None,
        start_after: typing.Optional[str] = None,
        order: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        filter: typing.Optional[typing.Union[str, typing.Sequence[str]]] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListMembersResponse:
        """
        List all members

        Parameters
        ----------
        limit : typing.Optional[int]
            Number of `Member` objects to return in this page. Defaults to 100.

        start_after : typing.Optional[str]
            Return `Member` objects starting after this `name`.

        order : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Select a field to order the results by. Defaults to `name`. To control the direction of the sorting, append
            `[asc]` or `[desc]` to the field name. For example, `name[desc]` will sort the results by `name` in descending order.
            The ordering defaults to `asc` if not specified. May be used multiple times to order by multiple fields, and the
            ordering is applied in the order the fields are specified.

        filter : typing.Optional[typing.Union[str, typing.Sequence[str]]]
            Filter results by this query. For more information on filtering, refer to our Filtering Guide. Defaults to no filter.
            If used more than once, the queries are ANDed together.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListMembersResponse

        Examples
        --------
        import asyncio

        from synqly.client import AsyncSynqlyManagement

        client = AsyncSynqlyManagement(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.members.list(
                limit=1,
                start_after="string",
                order="string",
                filter="string",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/members",
            method="GET",
            params={"limit": limit, "start_after": start_after, "order": order, "filter": filter},
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(ListMembersResponse, construct_type(type_=ListMembersResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(
        self, member_id: MemberId, *, request_options: typing.Optional[RequestOptions] = None
    ) -> GetMemberResponse:
        """
        Retrieve a Member by ID

        Parameters
        ----------
        member_id : MemberId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetMemberResponse

        Examples
        --------
        import asyncio

        from synqly.client import AsyncSynqlyManagement

        client = AsyncSynqlyManagement(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.members.get(
                member_id="string",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/members/{jsonable_encoder(member_id)}", method="GET", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(GetMemberResponse, construct_type(type_=GetMemberResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        name: str,
        secret: str,
        options: MemberOptions,
        fullname: typing.Optional[str] = OMIT,
        nickname: typing.Optional[str] = OMIT,
        picture: typing.Optional[str] = OMIT,
        role_binding: typing.Optional[typing.Sequence[RoleName]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> CreateMemberResponse:
        """
        Add a new member for this Organization.

        Parameters
        ----------
        name : str
            Email name to use for this Member. Also used for duplicate detection and default sort order.

        secret : str
            Member secret used to logon. Must be at least 8 characters long and fewer than 72 characters. There are no restrictions on the characters used; however, the secret must be sufficiently complex. It cannot be a common word, previously leaked password, or easily guessed sequences like `qwerty` or `12345`.

        options : MemberOptions

        fullname : typing.Optional[str]
            User's full display name. Defaults to the same value as the 'name' field if not specified.

        nickname : typing.Optional[str]
            User's nickname

        picture : typing.Optional[str]
            Url of user's picture

        role_binding : typing.Optional[typing.Sequence[RoleName]]
            Roles granted to this member. Tokens inherit this access. Defaults to `member`.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        CreateMemberResponse

        Examples
        --------
        import asyncio

        from synqly import MemberOptions
        from synqly.client import AsyncSynqlyManagement

        client = AsyncSynqlyManagement(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.members.create(
                name="string",
                fullname="string",
                nickname="string",
                picture="string",
                secret="string",
                role_binding=["string"],
                options=MemberOptions(
                    ttl="string",
                    options=["disabled"],
                    token_ttl="string",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/members",
            method="POST",
            json={
                "name": name,
                "fullname": fullname,
                "nickname": nickname,
                "picture": picture,
                "secret": secret,
                "role_binding": role_binding,
                "options": options,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(CreateMemberResponse, construct_type(type_=CreateMemberResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        member_id: MemberId,
        *,
        id: MemberId,
        state: State,
        last_logon: dt.datetime,
        fullname: str,
        ttl: str,
        token_ttl: str,
        expires: dt.datetime,
        pin_expires: dt.datetime,
        role_binding: typing.Sequence[RoleName],
        name: str,
        created_at: dt.datetime,
        updated_at: dt.datetime,
        nickname: typing.Optional[str] = OMIT,
        picture: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> UpdateMemberResponse:
        """
        Update a Member by ID

        Parameters
        ----------
        member_id : MemberId

        id : MemberId

        state : State

        last_logon : dt.datetime
            Last logon time

        fullname : str
            User's full display name.

        ttl : str

        token_ttl : str

        expires : dt.datetime

        pin_expires : dt.datetime

        role_binding : typing.Sequence[RoleName]
            Roles granted to this member. Tokens inherit this access.

        name : str
            Human-readable name for this resource

        created_at : dt.datetime
            Time object was originally created

        updated_at : dt.datetime
            Last time object was updated

        nickname : typing.Optional[str]
            User's nickname

        picture : typing.Optional[str]
            Url of user's picture

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        UpdateMemberResponse

        Examples
        --------
        import asyncio
        import datetime

        from synqly.client import AsyncSynqlyManagement

        client = AsyncSynqlyManagement(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.members.update(
                member_id="string",
                id="string",
                state="disabled",
                last_logon=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                fullname="string",
                nickname="string",
                picture="string",
                ttl="string",
                token_ttl="string",
                expires=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                pin_expires=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                role_binding=["string"],
                name="string",
                created_at=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
                updated_at=datetime.datetime.fromisoformat(
                    "2024-01-15 09:30:00+00:00",
                ),
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/members/{jsonable_encoder(member_id)}",
            method="PUT",
            json={
                "id": id,
                "state": state,
                "last_logon": last_logon,
                "fullname": fullname,
                "nickname": nickname,
                "picture": picture,
                "ttl": ttl,
                "token_ttl": token_ttl,
                "expires": expires,
                "pin_expires": pin_expires,
                "role_binding": role_binding,
                "name": name,
                "created_at": created_at,
                "updated_at": updated_at,
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(UpdateMemberResponse, construct_type(type_=UpdateMemberResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def patch(
        self,
        member_id: MemberId,
        *,
        request: typing.Sequence[PatchOperation],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> PatchMemberResponse:
        """
        Update a Member by ID

        Parameters
        ----------
        member_id : MemberId

        request : typing.Sequence[PatchOperation]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        PatchMemberResponse

        Examples
        --------
        import asyncio

        from synqly import PatchOperation
        from synqly.client import AsyncSynqlyManagement

        client = AsyncSynqlyManagement(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.members.patch(
                member_id="string",
                request=[
                    PatchOperation(
                        op="add",
                        path="string",
                        from_="string",
                        value={"key": "value"},
                    )
                ],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/members/{jsonable_encoder(member_id)}",
            method="PATCH",
            json=request,
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(PatchMemberResponse, construct_type(type_=PatchMemberResponse, object_=_response.json()))  # type: ignore
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, member_id: MemberId, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a Member by ID. Also deletes all Tokens for the Member.

        Parameters
        ----------
        member_id : MemberId

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        import asyncio

        from synqly.client import AsyncSynqlyManagement

        client = AsyncSynqlyManagement(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.members.delete(
                member_id="string",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v1/members/{jsonable_encoder(member_id)}", method="DELETE", request_options=request_options
        )
        try:
            if 200 <= _response.status_code < 300:
                return
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 405:
                raise MethodNotAllowedError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 409:
                raise ConflictError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 415:
                raise UnsupportedMediaTypeError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 429:
                raise TooManyRequestsError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(Problem, construct_type(type_=Problem, object_=_response.json()))  # type: ignore
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
