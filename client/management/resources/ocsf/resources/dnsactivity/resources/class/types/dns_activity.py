# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic

from ........core.datetime_utils import serialize_datetime
from ...base.types.timestamp import Timestamp
from ...objects.types.actor import Actor
from ...objects.types.api import Api
from ...objects.types.attack import Attack
from ...objects.types.cloud import Cloud
from ...objects.types.device import Device
from ...objects.types.dns_answer import DnsAnswer
from ...objects.types.dns_query import DnsQuery
from ...objects.types.enrichment import Enrichment
from ...objects.types.malware import Malware
from ...objects.types.metadata import Metadata
from ...objects.types.network_connection_info import NetworkConnectionInfo
from ...objects.types.network_endpoint import NetworkEndpoint
from ...objects.types.network_proxy import NetworkProxy
from ...objects.types.network_traffic import NetworkTraffic
from ...objects.types.object import Object
from ...objects.types.observable import Observable
from ...objects.types.tls import Tls
from .activity_id import ActivityId
from .category_uid import CategoryUid
from .class_uid import ClassUid
from .disposition_id import DispositionId
from .rcode_id import RcodeId
from .severity_id import SeverityId
from .status_id import StatusId
from .type_uid import TypeUid


class DnsActivity(pydantic.BaseModel):
    """
    DNS Activity events report DNS queries and answers as seen on the network.
    """

    activity_id: ActivityId = pydantic.Field(
        description="The normalized identifier of the activity that triggered the event."
    )
    activity_name: typing.Optional[str] = pydantic.Field(
        description="The event activity name, as defined by the activity_id."
    )
    actor: typing.Optional[Actor] = pydantic.Field(
        description="The actor object describes details about the user/role/process that was the source of the activity."
    )
    answers: typing.Optional[typing.List[DnsAnswer]] = pydantic.Field(
        description="The Domain Name System (DNS) answers."
    )
    api: typing.Optional[Api] = pydantic.Field(
        description="Describes details about a typical API (Application Programming Interface) call."
    )
    app_name: typing.Optional[str] = pydantic.Field(
        description="The name of the application that is associated with the event or object."
    )
    attacks: typing.Optional[typing.List[Attack]] = pydantic.Field(
        description="An array of attacks associated with an event."
    )
    category_name: typing.Optional[str] = pydantic.Field(
        description="The event category name, as defined by category_uid value: <code>Network Activity</code>."
    )
    category_uid: CategoryUid = pydantic.Field(description="The category unique identifier of the event.")
    class_uid: ClassUid = pydantic.Field(
        description="The unique identifier of a class. A Class describes the attributes available in an event."
    )
    cloud: Cloud = pydantic.Field(
        description="Describes details about the Cloud environment where the event was originally created or logged."
    )
    connection_info: typing.Optional[NetworkConnectionInfo] = pydantic.Field(
        description="The network connection information."
    )
    count: typing.Optional[int] = pydantic.Field(
        description="The number of times that events in the same logical group occurred during the event <strong>Start Time</strong> to <strong>End Time</strong> period."
    )
    device: typing.Optional[Device] = pydantic.Field(description="An addressable device, computer system or host.")
    disposition: typing.Optional[str] = pydantic.Field(
        description="The event disposition name, normalized to the caption of the disposition_id value. In the case of 'Other', it is defined by the event source."
    )
    disposition_id: DispositionId = pydantic.Field(
        description="When security issues, such as malware or policy violations, are detected and possibly corrected, then <code>disposition_id</code> describes the action taken by the security product."
    )
    dst_endpoint: NetworkEndpoint = pydantic.Field(description="The responder (server) in a network connection.")
    duration: typing.Optional[int] = pydantic.Field(
        description="The event duration or aggregate time, the amount of time the event covers from <code>start_time</code> to <code>end_time</code> in milliseconds."
    )
    end_time: typing.Optional[Timestamp] = pydantic.Field(
        description="The end time of a time period, or the time of the most recent event included in the aggregate event."
    )
    end_time_dt: typing.Optional[dt.datetime] = pydantic.Field(
        description="The end time of a time period, or the time of the most recent event included in the aggregate event."
    )
    enrichments: typing.Optional[typing.List[Enrichment]] = pydantic.Field(
        description='The additional information from an external data source, which is associated with the event. For example add location information for the IP address in the DNS answers:</p><code>[{"name": "answers.ip", "value": "92.24.47.250", "type": "location", "data": {"city": "Socotra", "continent": "Asia", "coordinates": [-25.4153, 17.0743], "country": "YE", "desc": "Yemen"}}]</code>'
    )
    malware: typing.Optional[typing.List[Malware]] = pydantic.Field(
        description="The list of malware identified by a finding."
    )
    message: typing.Optional[str] = pydantic.Field(
        description="The description of the event, as defined by the event source."
    )
    metadata: Metadata = pydantic.Field(description="The metadata associated with the event.")
    observables: typing.Optional[typing.List[Observable]] = pydantic.Field(
        description="The observables associated with the event."
    )
    proxy: typing.Optional[NetworkProxy] = pydantic.Field(
        description="If a proxy connection is present, the connection from the client to the proxy server."
    )
    query: typing.Optional[DnsQuery] = pydantic.Field(description="The Domain Name System (DNS) query.")
    query_time: typing.Optional[Timestamp] = pydantic.Field(description="The Domain Name System (DNS) query time.")
    query_time_dt: typing.Optional[dt.datetime] = pydantic.Field(description="The Domain Name System (DNS) query time.")
    raw_data: typing.Optional[str] = pydantic.Field(description="The event data as received from the event source.")
    rcode: typing.Optional[str] = pydantic.Field(
        description="The DNS server response code, normalized to the caption of the rcode_id value. In the case of 'Other', it is defined by the event source."
    )
    rcode_id: typing.Optional[RcodeId] = pydantic.Field(
        description="The normalized identifier of the DNS server response code. See <a target='_blank' href='https://datatracker.ietf.org/doc/html/rfc6895'>RFC-6895</a>."
    )
    response_time: typing.Optional[Timestamp] = pydantic.Field(
        description="The Domain Name System (DNS) response time."
    )
    response_time_dt: typing.Optional[dt.datetime] = pydantic.Field(
        description="The Domain Name System (DNS) response time."
    )
    severity: typing.Optional[str] = pydantic.Field(
        description="The event severity, normalized to the caption of the severity_id value. In the case of 'Other', it is defined by the event source."
    )
    severity_id: SeverityId = pydantic.Field(
        description="<p>The normalized identifier of the event severity.</p>The normalized severity is a measurement the effort and expense required to manage and resolve an event or incident. Smaller numerical values represent lower impact events, and larger numerical values represent higher impact events."
    )
    src_endpoint: NetworkEndpoint = pydantic.Field(description="The initiator (client) of the network connection.")
    start_time: typing.Optional[Timestamp] = pydantic.Field(
        description="The start time of a time period, or the time of the least recent event included in the aggregate event."
    )
    start_time_dt: typing.Optional[dt.datetime] = pydantic.Field(
        description="The start time of a time period, or the time of the least recent event included in the aggregate event."
    )
    status: typing.Optional[str] = pydantic.Field(
        description="The event status, normalized to the caption of the status_id value. In the case of 'Other', it is defined by the event source."
    )
    status_code: typing.Optional[str] = pydantic.Field(
        description="The event status code, as reported by the event source.<br /><br />For example, in a Windows Failed Authentication event, this would be the value of 'Failure Code', e.g. 0x18."
    )
    status_detail: typing.Optional[str] = pydantic.Field(
        description="The status details contains additional information about the event outcome."
    )
    status_id: typing.Optional[StatusId] = pydantic.Field(description="The normalized identifier of the event status.")
    time: Timestamp = pydantic.Field(description="The normalized event occurrence time.")
    time_dt: typing.Optional[dt.datetime] = pydantic.Field(description="The normalized event occurrence time.")
    timezone_offset: typing.Optional[int] = pydantic.Field(
        description="The number of minutes that the reported event <code>time</code> is ahead or behind UTC, in the range -1,080 to +1,080."
    )
    tls: typing.Optional[Tls] = pydantic.Field(description="The Transport Layer Security (TLS) attributes.")
    traffic: typing.Optional[NetworkTraffic] = pydantic.Field(
        description="The network traffic refers to the amount of data moving across a network at a given point of time. Intended to be used alongside Network Connection."
    )
    type_name: typing.Optional[str] = pydantic.Field(description="The event type name, as defined by the type_uid.")
    type_uid: TypeUid = pydantic.Field(
        description="The event type ID. It identifies the event's semantics and structure. The value is calculated by the logging system as: <code>class_uid * 100 + activity_id</code>."
    )
    unmapped: typing.Optional[Object] = pydantic.Field(
        description="The attributes that are not mapped to the event schema. The names and values of those attributes are specific to the event source."
    )

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().dict(**kwargs_with_defaults)

    class Config:
        frozen = True
        smart_union = True
        json_encoders = {dt.datetime: serialize_datetime}
